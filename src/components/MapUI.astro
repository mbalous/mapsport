---
// src/components/MapUI.astro
interface Props {
  initialActivities: any[];
  userProfile?: any;
}
const { initialActivities, userProfile } = Astro.props;
---

<div class="flex h-screen bg-gray-950 text-gray-100 overflow-hidden font-sans">
  {/* Sidebar for Activity Selection */}
  <aside
    class="w-80 border-r border-gray-800 bg-gray-950/80 backdrop-blur-md flex flex-col z-10 shadow-2xl"
  >
    <div class="p-6 border-b border-gray-800 flex items-center justify-between">
      <div>
        <h1
          class="text-2xl font-bold bg-gradient-to-r from-orange-400 to-rose-500 bg-clip-text text-transparent"
        >
          Strava Map
        </h1>
        <p class="text-xs text-gray-400 mt-1">
          Select up to 10 activities to visualize.
        </p>
      </div>
      {
        userProfile && (
          <div class="flex items-center gap-3 bg-gray-900/50 pr-4 pl-1 py-1 rounded-full border border-gray-800">
            <img
              src={userProfile.profile_medium || userProfile.profile}
              alt={userProfile.firstname}
              class="w-8 h-8 rounded-full border border-gray-700 bg-gray-900 object-cover"
            />
            <div class="text-sm font-medium">
              <span class="text-gray-200">{userProfile.firstname}</span>
              <span class="text-gray-400">{userProfile.lastname}</span>
            </div>
          </div>
        )
      }
    </div>

    {/* Activity List Container */}
    <div class="flex-1 overflow-y-auto p-4 space-y-3" id="activity-list">
      {/* Populated by JS */}
    </div>

    {/* Pagination Controls */}
    <div
      class="p-4 border-t border-gray-800 flex justify-between items-center bg-gray-900/50"
    >
      <button
        id="prev-page"
        class="px-3 py-1.5 rounded-md bg-gray-800 text-sm hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
      >
        Previous
      </button>
      <span id="page-indicator" class="text-sm text-gray-400">Page 1</span>
      <button
        id="next-page"
        class="px-3 py-1.5 rounded-md bg-gray-800 text-sm hover:bg-gray-700 transition-colors"
      >
        Next
      </button>
    </div>
  </aside>

  {/* Main Map Area */}
  <main class="flex-1 relative">
    <div id="map" class="w-full h-full bg-gray-900 z-0"></div>

    {/* Statistical Overlay */}
    <div
      id="stats-overlay"
      class="absolute bottom-6 right-6 bg-gray-950/90 backdrop-blur-md border border-gray-800 p-6 rounded-2xl shadow-2xl z-10 transition-all duration-300 opacity-0 translate-y-4"
    >
      <h2
        class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-4"
      >
        Combined Stats
      </h2>
      <div class="grid grid-cols-2 gap-6">
        <div>
          <p class="text-xs text-gray-500">Distance</p>
          <p id="stat-distance" class="text-2xl font-bold text-white">
            0<span class="text-sm text-gray-400 ml-1">km</span>
          </p>
        </div>
        <div>
          <p class="text-xs text-gray-500">Elevation</p>
          <p id="stat-elevation" class="text-2xl font-bold text-white">
            0<span class="text-sm text-gray-400 ml-1">m</span>
          </p>
        </div>
        <div class="col-span-2">
          <p class="text-xs text-gray-500">Moving Time</p>
          <p id="stat-time" class="text-xl font-bold text-white">0h 0m</p>
        </div>
      </div>
    </div>

    {/* Download Button */}
    <button
      id="download-btn"
      class="absolute top-6 right-6 bg-white text-black px-4 py-2 rounded-full font-medium shadow-lg hover:shadow-xl hover:scale-105 transition-all z-10 flex items-center gap-2 opacity-0 pointer-events-none"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        ><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline
          points="7 10 12 15 17 10"></polyline><line
          x1="12"
          x2="12"
          y1="15"
          y2="3"></line></svg
      >
      Download Map
    </button>
  </main>
</div>

{/* Leaflet CSS */}
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>

<script define:vars={{ initialActivities }}>
  // Pass initial SSR activities to window
  window.__INITIAL_ACTIVITIES__ = initialActivities;
</script>

<style is:global>
  /* Override default Leaflet white background when zoomed out */
  .leaflet-container {
    background: #262626 !important; /* Matches CartoDB Dark Matter ocean color perfectly */
  }
</style>

<script>
  import L from "leaflet";

  // Decoding Polyline utility (Vanilla JS, 15 lines equivalent)
  function decodePolyline(str, precision) {
    let index = 0,
      lat = 0,
      lng = 0,
      coordinates = [],
      shift = 0,
      result = 0,
      byte = null,
      latitude_change,
      longitude_change,
      factor = Math.pow(10, Number.isInteger(precision) ? precision : 5);
    while (index < str.length) {
      byte = null;
      shift = 0;
      result = 0;
      do {
        byte = str.charCodeAt(index++) - 63;
        result |= (byte & 0x1f) << shift;
        shift += 5;
      } while (byte >= 0x20);
      latitude_change = result & 1 ? ~(result >> 1) : result >> 1;
      shift = result = 0;
      do {
        byte = str.charCodeAt(index++) - 63;
        result |= (byte & 0x1f) << shift;
        shift += 5;
      } while (byte >= 0x20);
      longitude_change = result & 1 ? ~(result >> 1) : result >> 1;
      lat += latitude_change;
      lng += longitude_change;
      coordinates.push([lat / factor, lng / factor]);
    }
    return coordinates;
  }

  // State
  let currentPage = 1;
  let activities = window.__INITIAL_ACTIVITIES__ || [];
  let selectedActivities = new Map(); // id -> activity full object
  const MAX_ACTIVITIES = 10;

  // Geolocation cache and queue
  const locationCache = new Map();
  const locationQueue = [];
  let isFetchingLocation = false;

  async function processLocationQueue() {
    if (isFetchingLocation || locationQueue.length === 0) return;
    isFetchingLocation = true;

    const { act, spanId } = locationQueue.shift();
    if (!act.start_latlng || act.start_latlng.length < 2) {
      isFetchingLocation = false;
      processLocationQueue();
      return;
    }

    const [lat, lng] = act.start_latlng;
    const cacheKey = `${lat.toFixed(2)},${lng.toFixed(2)}`; // cache heavily by ~1km radius

    if (locationCache.has(cacheKey)) {
      updateLocationDOM(spanId, locationCache.get(cacheKey));
    } else {
      try {
        const res = await fetch(
          `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=en`,
        );
        if (res.ok) {
          const data = await res.json();
          const city = data.city || data.locality || data.principalSubdivision;
          const country = data.countryName;
          const locStr = [city, country].filter(Boolean).join(", ");

          if (locStr) {
            locationCache.set(cacheKey, locStr);
            updateLocationDOM(spanId, locStr);
          }
        }
      } catch (err) {
        // Silently ignore to not clutter console
      }
      // Small delay to be polite
      await new Promise((r) => setTimeout(r, 250));
    }

    isFetchingLocation = false;
    processLocationQueue();
  }

  function updateLocationDOM(spanId, locStr) {
    const el = document.getElementById(spanId);
    if (el && locStr) {
      el.innerText = ` • ${locStr}`;
      // Remove pulsing skeleton if we added one
      el.classList.remove(
        "animate-pulse",
        "bg-gray-800",
        "text-transparent",
        "rounded",
      );
    }
  }

  // Map Instance
  let map;
  let polylineLayerGroup;

  function initMap() {
    const worldBounds = L.latLngBounds(L.latLng(-90, -180), L.latLng(90, 180));
    map = L.map("map", {
      zoomControl: false,
      minZoom: 3,
      maxBounds: worldBounds,
      maxBoundsViscosity: 1.0,
    }).setView([20, 0], 3);
    // Dark mode tiles (CartoDB Dark Matter)
    L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      {
        attribution: "&copy; OpenStreetMap contributors &copy; CARTO",
        subdomains: "abcd",
        maxZoom: 20,
        minZoom: 3,
      },
    ).addTo(map);

    polylineLayerGroup = L.layerGroup().addTo(map);
  }

  function renderActivityList() {
    const listEl = document.getElementById("activity-list");
    if (!listEl) return;

    listEl.innerHTML = "";

    if (activities.length === 0) {
      listEl.innerHTML =
        '<p class="text-sm text-gray-500">No activities found.</p>';
      return;
    }

    activities.forEach((act) => {
      // Don't render items without a polyline map
      if (!act.map || !act.map.summary_polyline) return;

      const isSelected = selectedActivities.has(act.id);
      const isMaxedOut =
        selectedActivities.size >= MAX_ACTIVITIES && !isSelected;

      const item = document.createElement("label");
      item.className = `flex flex-col p-3 rounded-xl border transition-all cursor-pointer select-none
        ${isSelected ? "bg-orange-500/10 border-orange-500/50" : "bg-gray-900/50 border-gray-800 hover:border-gray-700"}
        ${isMaxedOut ? "opacity-50 cursor-not-allowed grayscale" : ""}
      `;

      // Formatting
      const distance = (act.distance / 1000).toFixed(1);
      const date = new Date(act.start_date_local).toLocaleDateString();

      const actHours = Math.floor(act.moving_time / 3600);
      const actMins = Math.floor((act.moving_time % 3600) / 60);
      const durationStr =
        actHours > 0 ? `${actHours}h ${actMins}m` : `${actMins}m`;

      const spanId = `loc-${act.id}`;

      // If we already resolved location in prior render, use it
      let defaultLocHTML = `<span id="${spanId}" class="animate-pulse bg-gray-800 text-transparent rounded">Loading location...</span>`;
      if (act.start_latlng && act.start_latlng.length >= 2) {
        const [lat, lng] = act.start_latlng;
        const cacheKey = `${lat.toFixed(2)},${lng.toFixed(2)}`;
        if (locationCache.has(cacheKey)) {
          defaultLocHTML = `<span id="${spanId}"> • ${locationCache.get(cacheKey)}</span>`;
        } else {
          // Queue resolution for this activity
          locationQueue.push({ act, spanId });
        }
      }

      item.innerHTML = `
        <div class="flex items-start gap-3">
          <input type="checkbox" class="mt-1 w-4 h-4 rounded border-gray-600 bg-gray-800 text-orange-500 focus:ring-orange-500/50 focus:ring-offset-gray-950" 
            ${isSelected ? "checked" : ""} 
            ${isMaxedOut ? "disabled" : ""} value="${act.id}" />
          <div class="flex-1 min-w-0">
            <h3 class="text-sm font-medium text-gray-200 truncate group-hover:text-white transition-colors">${act.name}</h3>
            <p class="text-xs text-gray-500 mt-0.5">${date}${defaultLocHTML} • ${act.type}</p>
            <div class="mt-2 flex items-center gap-2 text-xs font-semibold text-gray-400">
              <span>${distance} km</span>
              <span>•</span>
              <span>${durationStr}</span>
            </div>
          </div>
        </div>
      `;

      item.querySelector("input").addEventListener("change", (e) => {
        if (e.target.checked) {
          if (selectedActivities.size < MAX_ACTIVITIES) {
            selectedActivities.set(act.id, act);
          } else {
            e.target.checked = false; // Revert if bypassed
            alert("Maximum 10 activities allowed.");
            return;
          }
        } else {
          selectedActivities.delete(act.id);
        }

        renderActivityList(); // Re-render to update selected styling and max-out state
        updateMapAndStats();
      });

      listEl.appendChild(item);
    });

    // Start resolving queued locations
    if (locationQueue.length > 0 && !isFetchingLocation) {
      processLocationQueue();
    }
  }

  function updateMapAndStats() {
    polylineLayerGroup.clearLayers();

    let totalDist = 0;
    let totalElev = 0;
    let totalTime = 0; // seconds

    const bounds = L.latLngBounds([]);

    // We assign different colors to polylines. Let's create a beautiful gradient scale.
    const colors = [
      "#f97316",
      "#ef4444",
      "#ec4899",
      "#d946ef",
      "#8b5cf6",
      "#6366f1",
      "#3b82f6",
      "#0ea5e9",
      "#14b8a6",
      "#22c55e",
    ];
    let idx = 0;

    selectedActivities.forEach((act) => {
      const coords = decodePolyline(act.map.summary_polyline, 5);
      if (coords.length > 0) {
        const polyline = L.polyline(coords, {
          color: colors[idx % colors.length],
          weight: 3,
          opacity: 0.8,
          lineJoin: "round",
          lineCap: "round",
        });
        polylineLayerGroup.addLayer(polyline);

        // Add coordinates to bounds so we can map fit
        coords.forEach((c) => bounds.extend(c));

        totalDist += act.distance;
        totalElev += act.total_elevation_gain;
        totalTime += act.moving_time;
        idx++;
      }
    });

    if (selectedActivities.size > 0 && bounds.isValid()) {
      // Zoom out a bit from the tightest bound for better visual effect
      map.flyToBounds(bounds, { padding: [50, 50], duration: 1 });
    }

    // Update stats UI
    const overlay = document.getElementById("stats-overlay");
    const dlBtn = document.getElementById("download-btn");

    if (selectedActivities.size > 0) {
      overlay.classList.remove("opacity-0", "translate-y-4");
      overlay.classList.add("opacity-100", "translate-y-0");

      dlBtn.classList.remove("opacity-0", "pointer-events-none");
      dlBtn.classList.add("opacity-100", "pointer-events-auto");

      document.getElementById("stat-distance").innerHTML =
        `${(totalDist / 1000).toFixed(1)}<span class="text-sm text-gray-400 ml-1">km</span>`;
      document.getElementById("stat-elevation").innerHTML =
        `${Math.round(totalElev)}<span class="text-sm text-gray-400 ml-1">m</span>`;

      const hours = Math.floor(totalTime / 3600);
      const mins = Math.floor((totalTime % 3600) / 60);
      document.getElementById("stat-time").innerText = `${hours}h ${mins}m`;
    } else {
      overlay.classList.add("opacity-0", "translate-y-4");
      overlay.classList.remove("opacity-100", "translate-y-0");

      dlBtn.classList.add("opacity-0", "pointer-events-none");
      dlBtn.classList.remove("opacity-100", "pointer-events-auto");
    }
  }

  async function loadPage(page) {
    const listEl = document.getElementById("activity-list");
    listEl.innerHTML = `
      <div class="flex flex-col items-center justify-center p-12 text-gray-400">
        <div class="animate-spin h-8 w-8 border-4 border-orange-500 border-t-transparent rounded-full mb-4"></div>
        <p class="text-sm font-medium">Loading activities...</p>
      </div>
    `;

    try {
      const res = await fetch(`/api/activities?page=${page}&per_page=30`);
      if (res.ok) {
        activities = await res.json();
        currentPage = page;
        document.getElementById("page-indicator").innerText =
          `Page ${currentPage}`;
        document.getElementById("prev-page").disabled = currentPage === 1;
        renderActivityList();
      } else {
        throw new Error("Failed to fetch");
      }
    } catch (err) {
      listEl.innerHTML =
        '<p class="text-sm text-red-500 p-4">Error loading activities.</p>';
    }
  }

  // Bind Events
  document.getElementById("prev-page").addEventListener("click", () => {
    if (currentPage > 1) loadPage(currentPage - 1);
  });

  document.getElementById("next-page").addEventListener("click", () => {
    loadPage(currentPage + 1);
  });

  // Export to image feature
  document
    .getElementById("download-btn")
    .addEventListener("click", async () => {
      // Dynamically import html-to-image to save initial footprint
      const htmlToImage = await import("html-to-image");

      const node = document.querySelector("main");
      const btn = document.getElementById("download-btn");

      // Hide download button from the screenshot
      btn.style.display = "none";

      try {
        const dataUrl = await htmlToImage.toPng(node, {
          quality: 0.95,
          pixelRatio: 2, // High Resolution
        });

        let baseName = "strava-map";
        if (selectedActivities.size > 0) {
          // Get the first selected activity
          const firstActivity = Array.from(selectedActivities.values())[0];
          // Sanitize the name for use in a file system
          baseName = firstActivity.name
            .replace(/[^a-z0-9]/gi, "_")
            .toLowerCase();
        }

        const a = document.createElement("a");
        a.href = dataUrl;
        a.download = `${baseName}-${Date.now()}.png`;
        a.click();
      } catch (err) {
        console.error(err);
        alert("Failed to generate image.");
      } finally {
        btn.style.display = "flex";
      }
    });

  // Init
  initMap();
  document.getElementById("prev-page").disabled = currentPage === 1;
  renderActivityList();
</script>
